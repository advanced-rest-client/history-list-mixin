<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>history-list-mixin test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <!-- Required by the request model -->
  <!-- <script src="../../../pouchdb/dist/pouchdb.js"></script> -->
  <script src="../../../pouchdb-quick-search/dist/pouchdb.quick-search.min.js"></script>
</head>
<body>

  <test-fixture id="Basic">
    <template>
      <request-model></request-model>
      <test-element no-auto></test-element>
    </template>
  </test-fixture>

  <test-fixture id="QueryLimit">
    <template>
      <request-model></request-model>
      <test-element no-auto page-limit="10"></test-element>
    </template>
  </test-fixture>

  <test-fixture id="NoModel">
    <template>
      <test-element no-auto page-limit="10"></test-element>
    </template>
  </test-fixture>

  <test-fixture id="WithIndexer">
    <template>
      <request-model></request-model>
      <url-indexer></url-indexer>
      <test-element no-auto></test-element>
    </template>
  </test-fixture>

  <script type="module">
  import '../../../@advanced-rest-client/arc-models/request-model.js';
  import '../../../@advanced-rest-client/arc-models/url-indexer.js';
  import {DataGenerator} from '../../../@advanced-rest-client/arc-data-generator/arc-data-generator.js';
  import './test-element.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';

  suite('history-list-mixin', () => {
    suite('queryOptions computations', () => {
      test('Sets default query limit', () => {
        const element = fixture('Basic')[1];
        assert.typeOf(element.queryOptions, 'object', 'queryOptions is computed');
        assert.equal(element.queryOptions.limit, 150);
      });

      test('Respects page-limit attribute', () => {
        const element = fixture('QueryLimit')[1];
        assert.equal(element.queryOptions.limit, 10);
      });

      test('Sets startkey property', () => {
        const element = fixture('Basic')[1];
        element._queryStartKey = 'test';
        assert.equal(element.queryOptions.startkey, 'test');
      });

      test('Sets skip property', () => {
        const element = fixture('Basic')[1];
        element._querySkip = 1;
        assert.equal(element.queryOptions.skip, 1);
      });

      test('Sets descending property', () => {
        const element = fixture('Basic')[1];
        assert.isTrue(element.queryOptions.descending);
      });

      test('Sets include_docs property', () => {
        const element = fixture('Basic')[1];
        assert.isTrue(element.queryOptions.include_docs);
      });
    });

    suite('_computeQueryOptions()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Sets descending property', () => {
        const result = element._computeQueryOptions();
        assert.isTrue(result.descending);
      });

      test('Sets include_docs property', () => {
        const result = element._computeQueryOptions();
        assert.isTrue(result.include_docs);
      });

      test('Sets limit', () => {
        const result = element._computeQueryOptions(10);
        assert.equal(result.limit, 10);
      });

      test('Sets startkey property', () => {
        const result = element._computeQueryOptions(10, 'test');
        assert.equal(result.startkey, 'test');
      });

      test('Sets skip property', () => {
        const result = element._computeQueryOptions(10, 'test', 1);
        assert.equal(result.skip, 1);
      });
    });

    suite('_computeDataUnavailable()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Returns true if all undefined', () => {
        const result = element._computeDataUnavailable();
        assert.isTrue(result);
      });

      test('Returns true if all false', () => {
        const result = element._computeDataUnavailable(false, false, false);
        assert.isTrue(result);
      });

      test('Returns false if hasRequests is true', () => {
        const result = element._computeDataUnavailable(true, false, false);
        assert.isFalse(result);
      });

      test('Returns false if loading is true', () => {
        const result = element._computeDataUnavailable(false, true, false);
        assert.isFalse(result);
      });

      test('Returns false if isSearch is true', () => {
        const result = element._computeDataUnavailable(false, false, true);
        assert.isFalse(result);
      });
    });

    suite('_computeSearchListEmpty()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Returns false if all undefined', () => {
        const result = element._computeSearchListEmpty();
        assert.isFalse(result);
      });

      test('Returns false if all false', () => {
        const result = element._computeSearchListEmpty(false, false, false);
        assert.isFalse(result);
      });

      test('Returns false if hasRequests is true', () => {
        const result = element._computeSearchListEmpty(true, false, false);
        assert.isFalse(result);
      });

      test('Returns false if loading is true', () => {
        const result = element._computeSearchListEmpty(false, true, false);
        assert.isFalse(result);
      });

      test('Returns true if isSearch is true', () => {
        const result = element._computeSearchListEmpty(false, false, true);
        assert.isTrue(result);
      });
    });

    suite('_dataImportHandler()', () => {
      let element;
      setup(() => {
        element = fixture('Basic')[1];
      });

      test('Calls refresh() when called', () => {
        let called = false;
        element.refresh = () => called = true;
        element._dataImportHandler();
        assert.isTrue(called);
      });

      test('Calls refresh() when data-imported is handled', () => {
        let called = false;
        element.refresh = () => called = true;
        document.body.dispatchEvent(new CustomEvent('data-imported', {
          bubbles: true
        }));
        assert.isTrue(called);
      });
    });

    suite('_onDatabaseDestroy()', () => {
      let element;
      setup(() => {
        element = fixture('Basic')[1];
      });

      test('Calls refresh() when called with "history" datastore', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['history']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when called with "history-requests" datastore (legacy api)', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['history-requests']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when called with "all" datastore', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['history-requests']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when datastore is a string', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: 'history-requests'
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when datastore-destroyed is handled', () => {
        let called = false;
        element.refresh = () => called = true;
        document.body.dispatchEvent(new CustomEvent('datastore-destroyed', {
          bubbles: true,
          detail: {
            datastore: ['history']
          }
        }));
        assert.isTrue(called);
      });

      test('Do nothing when datastore not set', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {}
        });
        assert.isFalse(called);
      });

      test('Do nothing when datastore is not an array', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: true
          }
        });
        assert.isFalse(called);
      });

      test('Do nothing when datastore is history store', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: 'saved'
          }
        });
        assert.isFalse(called);
      });
    });

    suite('_processHistoryResults()', function() {
      let element;
      let data;
      setup(function() {
        element = fixture('Basic')[1];
        data = [{
          _id: '1',
          updated: 10
        }, {
          _id: '2',
          updated: 20
        }];
      });

      test('Do nothing if no response', function() {
        const result = element._processHistoryResults();
        assert.isUndefined(result);
      });

      test('Returns empty array when no response', function() {
        const result = element._processHistoryResults([]);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 0);
      });

      test('Returns a list of documents', function() {
        const result = element._processHistoryResults(data);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 2);
      });

      test('Documents are sorted by name', function() {
        const result = element._processHistoryResults(data);
        assert.equal(result[0]._id, '2');
        assert.equal(result[1]._id, '1');
      });

      test('Adds created property when missing', () => {
        const result = element._processHistoryResults(data);
        assert.typeOf(result[0].created, 'number');
      });

      test('Adds updated property when missing', () => {
        const result = element._processHistoryResults(data);
        assert.typeOf(result[0].updated, 'number');
      });

      test('Adds timeLabel property', () => {
        const result = element._processHistoryResults(data);
        assert.typeOf(result[0].timeLabel, 'string');
      });

      test('Adds header property', () => {
        const result = element._processHistoryResults(data);
        assert.typeOf(result[0].header, 'string');
      });

      test('Adds hasHeader property', () => {
        const result = element._processHistoryResults(data);
        assert.typeOf(result[0].hasHeader, 'boolean');
      });
    });

    suite('_ensureTimestamps()', () => {
      let element;
      let data;
      setup(function() {
        element = fixture('Basic')[1];
        data = [{
          _id: '1',
          created: 1
        }, {
          _id: '2',
          updated: 2
        }, {
          _id: '3'
        }];
      });

      test('Returns array', () => {
        const result = element._ensureTimestamps(data);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 3);
      });

      test('Adds "updated" property', () => {
        const result = element._ensureTimestamps(data);
        assert.typeOf(result[0].updated, 'number');
      });

      test('Adds "created" property', () => {
        const result = element._ensureTimestamps(data);
        assert.typeOf(result[1].created, 'number');
      });

      test('Adds both properties', () => {
        const result = element._ensureTimestamps(data);
        assert.typeOf(result[2].created, 'number');
        assert.typeOf(result[2].updated, 'number');
      });

      test('Returns the same values if present', function() {
        const created = 123456789;
        const updated = 987654321;
        const result = element._ensureTimestamps([{
          created,
          updated
        }]);
        assert.equal(result[0].created, created);
        assert.equal(result[0].updated, updated);
      });
    });

    suite('_sortHistoryResults()', () => {
      let element;
      let data;
      setup(function() {
        element = fixture('Basic')[1];
        data = [{
          _id: '1',
          updated: 3
        }, {
          _id: '2',
          updated: 1
        }, {
          _id: '3',
          updated: 2
        }];
      });

      test('Sorts the array', () => {
        data.sort(element._sortHistoryResults);
        assert.equal(data[0]._id, '1');
        assert.equal(data[1]._id, '3');
        assert.equal(data[2]._id, '2');
      });

      test('Returns 0 when times equal', () => {
        const a = {
          updated: 1
        };
        const b = {
          updated: 1
        };
        const result = element._sortHistoryResults(a, b);
        assert.equal(result, 0);
      });

      test('Returns -1 when A time is higher', () => {
        const a = {
          updated: 1
        };
        const b = {
          updated: 0
        };
        const result = element._sortHistoryResults(a, b);
        assert.equal(result, -1);
      });

      test('Returns 1 when B time is higher', () => {
        const a = {
          updated: 0
        };
        const b = {
          updated: 1
        };
        const result = element._sortHistoryResults(a, b);
        assert.equal(result, 1);
      });
    });

    suite('_getTodayTimestamp()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Returns a number', () => {
        const result = element._getTodayTimestamp();
        assert.typeOf(result, 'number');
      });

      test('Hours, minutes, seconds, and ms are removed ', () => {
        const result = element._getTodayTimestamp();
        const secs = String(result).substr(-5);
        assert.equal(secs, '00000');
      });

      test('Hours is set to 0', () => {
        const result = element._getTodayTimestamp();
        const date = new Date(result);
        assert.equal(date.getHours(), 0);
      });

      test('Minutes is set to 0', () => {
        const result = element._getTodayTimestamp();
        const date = new Date(result);
        assert.equal(date.getMinutes(), 0);
      });

      test('Seconds is set to 0', () => {
        const result = element._getTodayTimestamp();
        const date = new Date(result);
        assert.equal(date.getSeconds(), 0);
      });

      test('Milliseconds is set to 0', () => {
        const result = element._getTodayTimestamp();
        const date = new Date(result);
        assert.equal(date.getMilliseconds(), 0);
      });
    });

    suite('_getYesterdayTimestamp()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Returns a number', () => {
        const result = element._getYesterdayTimestamp(Date.now());
        assert.typeOf(result, 'number');
      });

      test('Is a day earlier', () => {
        const result = element._getYesterdayTimestamp(1541658370548);
        assert.equal(result, 1541571970548);
      });
    });

    suite('_appendItems()', function() {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Adds items to the list that doesn\'t exists', function() {
        const items = [{
          _id: 1
        }, {
          _id: 2
        }];
        assert.isUndefined(element.requests);
        element._appendItems(items);
        assert.typeOf(element.requests, 'array');
        assert.lengthOf(element.requests, 2);
      });

      test('Adds items to the list that already exists', function() {
        const requests = [{
          _id: 1
        }, {
          _id: 2
        }];
        element.requests = [{
          _id: 3
        }];
        element._appendItems(requests);
        assert.typeOf(element.requests, 'array');
        assert.lengthOf(element.requests, 3);
      });
    });

    function cancelRequestListEvent(element, requests) {
      if (!requests) {
        requests = [];
      }
      element.addEventListener('request-list', function f(e) {
        element.removeEventListener('request-list', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          rows: requests
        });
      });
    }

    suite('refresh()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Calles reset() function', () => {
        let called = false;
        element.reset = () => called = true;
        element.loadNext = () => {};
        element.refresh();
        assert.isTrue(called);
      });

      test('Calles loadNext() function', () => {
        let called = false;
        element.reset = () => {};
        element.loadNext = () => called = true;
        element.refresh();
        assert.isTrue(called);
      });
    });

    suite('reset()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Resets _queryStartKey', () => {
        element._queryStartKey = 'test';
        element.reset();
        assert.isUndefined(element._queryStartKey);
      });

      test('Resets _querySkip', () => {
        element._querySkip = 1;
        element.reset();
        assert.isUndefined(element._querySkip);
      });

      test('Resets requests', () => {
        element.requests = [{}];
        element.reset();
        assert.isUndefined(element.requests);
      });

      test('Resets isSearch', () => {
        element.isSearch = true;
        element.reset();
        assert.isFalse(element.isSearch);
      });

      test('Resets querying', () => {
        element._setQuerying(true);
        element.reset();
        assert.isFalse(element.querying);
      });
    });

    suite('loadNext()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Eventually calls _loadPage()', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.loadNext();
        afterNextRender(window, () => {
          assert.isTrue(called);
          done();
        });
      });

      test('Sets __makingQuery flag', (done) => {
        element._loadPage = () => done();
        element.loadNext();
        assert.isTrue(element.__makingQuery);
      });

      test('Clears __makingQuery flag after callback', (done) => {
        element._loadPage = () => {
          assert.isFalse(element.__makingQuery);
          done();
        };
        element.loadNext();
      });

      test('Do nothing when __makingQuery flag is set', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.__makingQuery = true;
        element.loadNext();
        afterNextRender(window, () => {
          assert.isFalse(called);
          done();
        });
      });

      test('Do nothing when isSearch flag is set', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.isSearch = true;
        element.loadNext();
        afterNextRender(window, () => {
          assert.isFalse(called);
          done();
        });
      });
    });

    suite('_dispatchListEvent()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Dispatches "request-list" custom event', () => {
        let called = false;
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          called = true;
        });
        element._dispatchListEvent();
        assert.isTrue(called);
      });

      test('Returns custom event', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result, 'customevent');
      });

      test('Custom event has detail object', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result.detail, 'object');
      });

      test('Detail contains type', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.equal(result.detail.type, 'history');
      });

      test('Detail contains queryOptions', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result.detail.queryOptions, 'object');
      });
    });

    suite('_loadPage()', () => {
      suiteSetup(() => {
        return DataGenerator.insertHistoryRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroyHistoryData();
      });

      test('Does nothing when isSearch is set', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element._loadPage();
        assert.isUndefined(element.querying);
        return p;
      });

      test('Returns promise', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element._loadPage();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Dispatches "request-list" custom event', () => {
        const element = fixture('Basic')[1];
        let called = false;
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          called = true;
          e.detail.result = Promise.resolve({
            rows: []
          });
        });
        const p = element._loadPage();
        assert.isTrue(called);
        return p;
      });

      test('Rejects when event is not handled', (done) => {
        const element = fixture('NoModel');
        let called = false;
        element._loadPage()
        .then(() => {
          done(new Error('Not rejected promise'));
          called = true;
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets querying property', () => {
        const element = fixture('NoModel');
        cancelRequestListEvent(element);
        const p = element._loadPage();
        assert.isTrue(element.querying);
        return p;
      });

      test('Resets querying when ready', () => {
        const element = fixture('NoModel');
        cancelRequestListEvent(element);
        const p = element._loadPage();
        return p.then(() => {
          assert.isFalse(element.querying);
        });
      });

      test('Resets querying when error', (done) => {
        const element = fixture('NoModel');
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          e.detail.result = Promise.reject(new Error('test'));
        });
        let called = false;
        element._loadPage().then(() => {
          called = true;
          done(new Error('Should not succeed'));
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets requests from the response', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.typeOf(element.requests, 'array');
          assert.lengthOf(element.requests, 25);
        });
      });

      test('Sets _queryStartKey', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.typeOf(element._queryStartKey, 'string');
        });
      });

      test('Sets _querySkip', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.equal(element._querySkip, 1);
        });
      });

      test('Calls _processHistoryResults() for documents', () => {
        let called = false;
        const element = fixture('Basic')[1];
        element._processHistoryResults = () => called = true;
        return element._loadPage()
        .then(() => {
          assert.isTrue(called);
        });
      });

      test('Calls notifyResize when defined', (done) => {
        let called = false;
        const element = fixture('Basic')[1];
        element.notifyResize = () => called = true;
        element._loadPage()
        .then(() => {
          afterNextRender(element, () => {
            assert.isTrue(called);
            done();
          });
        });
      });
    });

    suite('_handleError()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Throws an error', () => {
        assert.throws(function() {
          element._handleError(new Error('test'));
        });
      });
    });

    suite('_computeHistoryTime()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Returns an object', () => {
        const result = element._computeHistoryTime(Date.now());
        assert.typeOf(result, 'object');
      });

      test('Has formatted date', () => {
        const result = element._computeHistoryTime(Date.now());
        assert.typeOf(result.formatted, 'string');
      });

      test('Has time at midnight', () => {
        const result = element._computeHistoryTime(Date.now());
        assert.typeOf(result.time, 'number', 'Is a number');
        const secs = String(result.time).substr(-5);
        assert.equal(secs, '00000', 'time is removed');
      });

      test('Has timeLabel date', () => {
        const result = element._computeHistoryTime(Date.now());
        assert.typeOf(result.timeLabel, 'string');
      });
    });

    suite('_resetHistoryObject()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Returns the same passed object', () => {
        const obj = {};
        const result = element._resetHistoryObject(obj);
        assert.isTrue(result === obj);
      });

      test('Sets type', () => {
        const result = element._resetHistoryObject({});
        assert.equal(result.type, 'history');
      });

      test('Removes "header"', () => {
        const result = element._resetHistoryObject({header: 'test'});
        assert.isUndefined(result.header);
      });

      test('Removes "hasHeader"', () => {
        const result = element._resetHistoryObject({hasHeader: 'test'});
        assert.isUndefined(result.hasHeader);
      });

      test('Removes "timeLabel"', () => {
        const result = element._resetHistoryObject({timeLabel: 'test'});
        assert.isUndefined(result.timeLabel);
      });

      test('Removes "today"', () => {
        const result = element._resetHistoryObject({today: 'test'});
        assert.isUndefined(result.today);
      });
    });

    function cancelRequestQueryEvent(element, requests) {
      if (!requests) {
        requests = [];
      }
      element.addEventListener('request-query', function f(e) {
        element.removeEventListener('request-query', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          rows: requests
        });
      });
    }

    suite('_dispatchQueryEvent()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Dispatches "request-query" custom event', () => {
        let called = false;
        element.addEventListener('request-query', function f(e) {
          element.removeEventListener('request-query', f);
          e.preventDefault();
          called = true;
        });
        element._dispatchQueryEvent();
        assert.isTrue(called);
      });

      test('Returns custom event', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.typeOf(result, 'customevent');
      });

      test('Custom event has detail object', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.typeOf(result.detail, 'object');
      });

      test('Detail contains "type"', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.equal(result.detail.type, 'history');
      });

      test('Detail contains "q"', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent('test');
        assert.equal(result.detail.q, 'test');
      });
    });

    suite('query()', () => {
      suiteSetup(() => {
        return DataGenerator.insertHistoryRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroyHistoryData();
      });

      test('Does nothing when query is not set', () => {
        const element = fixture('Basic')[1];
        const p = element.query();
        assert.isUndefined(element.querying);
        return p;
      });

      test('Returns a promise when query is not set', () => {
        const element = fixture('Basic')[1];
        const p = element.query();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Returns promise when query is not set and isSearch', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element.query();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Calls refresh() when query is not set and isSearch', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        let called = false;
        element.refresh = () => called = true;
        const p = element.query();
        assert.isTrue(called);
        return p;
      });

      test('Dispatches "request-query" custom event', () => {
        const element = fixture('Basic')[1];
        let called = false;
        element.addEventListener('request-query', function f(e) {
          element.removeEventListener('request-query', f);
          e.preventDefault();
          called = true;
          e.detail.result = Promise.resolve([]);
        });
        const p = element.query('test');
        assert.isTrue(called);
        return p;
      });

      test('Rejects when event is not handled', (done) => {
        const element = fixture('NoModel');
        let called = false;
        element._loadPage()
        .then(() => {
          done(new Error('Not rejected promise'));
          called = true;
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets querying property', () => {
        const element = fixture('NoModel');
        cancelRequestQueryEvent(element);
        const p = element.query('test');
        assert.isTrue(element.querying);
        return p;
      });

      test('Resets querying when ready', () => {
        const element = fixture('NoModel');
        cancelRequestQueryEvent(element);
        const p = element.query('test');
        return p.then(() => {
          assert.isFalse(element.querying);
        });
      });
    });

    suite('_historyTypeChanged()', () => {
      let element;
      setup(() => {
        element = fixture('NoModel');
        element.requests = DataGenerator.generateHistoryRequestsData({
          requestsSize: 10
        });
      });
      test('Do nothing when type is not set', () => {
        element.type = undefined;
        const item = DataGenerator.generateHistoryObject();
        element._historyTypeChanged(item);
        assert.lengthOf(element.requests, 10);
      });

      test('Do nothing when type is not history', () => {
        element.type = 'saved';
        const item = DataGenerator.generateHistoryObject();
        element._historyTypeChanged(item);
        assert.lengthOf(element.requests, 10);
      });

      test('Do nothing when request type is not history', () => {
        const item = DataGenerator.generateSavedItem();
        element._historyTypeChanged(item);
        assert.lengthOf(element.requests, 10);
      });

      test('Creates requests array when request type is "history"', () => {
        element.requests = undefined;
        const item = DataGenerator.generateHistoryObject();
        item.type = 'history';
        element._historyTypeChanged(item);
        assert.lengthOf(element.requests, 1);
      });

      test('Creates requests array when request type is "history-requests"', () => {
        element.requests = undefined;
        const item = DataGenerator.generateHistoryObject();
        item.type = 'history-requests';
        element._historyTypeChanged(item);
        assert.lengthOf(element.requests, 1);
      });

      test('Calls _insertItem() when no requests', () => {
        element.requests = undefined;
        const item = DataGenerator.generateHistoryObject();
        const spy = sinon.spy(element, '_insertItem');
        element._historyTypeChanged(item);
        assert.isTrue(spy.called, 'Function is called');
        assert.deepEqual(spy.args[0][0], item, 'Argument is set');
      });

      test('Calls _insertItem() when request do not match current requests', () => {
        const item = DataGenerator.generateHistoryObject();
        const spy = sinon.spy(element, '_insertItem');
        element._historyTypeChanged(item);
        assert.isTrue(spy.called, 'Function is called');
        assert.deepEqual(spy.args[0][0], item, 'Argument is set');
      });

      test('Calls _removeItem() when item already exist', () => {
        const value = 'x-test: x-value';
        const item = Object.assign({}, element.requests[2]);
        item.headers = value;
        const spy = sinon.spy(element, '_removeItem');
        element._historyTypeChanged(item);
        assert.isTrue(spy.called, 'Function is called');
        assert.deepEqual(spy.args[0][0], 2, 'Argument is set');
      });
    });

    suite('_removeItem()', () => {
      let element;
      setup(() => {
        element = fixture('NoModel');
        element.requests = DataGenerator.generateHistoryRequestsData({
          requestsSize: 5
        });
      });

      test('Removes request at position', () => {
        const id = element.requests[1];
        element._removeItem(1);
        assert.lengthOf(element.requests, 4);
        const item = element.requests.some((item) => item._id === id);
        assert.isFalse(item);
      });

      test('Passes header to the next item', () => {
        const current = element.requests[2];
        current.hasHeader = true;
        current.header = 'test-header';
        current.today = true;
        element._removeItem(2);
        const next = element.requests[2];
        assert.equal(next.header, 'test-header');
        assert.isTrue(next.hasHeader);
        assert.isTrue(next.today);
      });

      test('Ignores header set when next item has header', () => {
        const current = element.requests[2];
        current.hasHeader = true;
        current.header = 'test-header';
        current.today = true;
        const next = element.requests[3];
        next.hasHeader = true;
        next.header = 'other-header';
        next.today = false;
        element._removeItem(2);
        const updated = element.requests[2];
        assert.equal(updated.header, 'other-header');
        assert.isTrue(updated.hasHeader);
        assert.isFalse(updated.today);
      });
    });

    suite('_insertItem()', () => {
      let element;
      setup(() => {
        element = fixture('NoModel');
        element.requests = DataGenerator.generateHistoryRequestsData({
          requestsSize: 2
        });
      });

      test('Creates "requests" if not exists', () => {
        element.requests = undefined;
        const item = DataGenerator.generateHistoryObject();
        element._insertItem(item);
        assert.lengthOf(element.requests, 1);
        assert.deepEqual(element.requests[0], item);
      });

      test('Calls _appendHistoryTimeHeader() when no requests', () => {
        element.requests = undefined;
        const item = DataGenerator.generateHistoryObject();
        const spy = sinon.spy(element, '_appendHistoryTimeHeader');
        element._insertItem(item);
        assert.isTrue(spy.called, 'Method is called');
        assert.deepEqual(spy.args[0][0], item, 'Passes item as an argument');
        assert.typeOf(spy.args[0][1], 'object', 'Passes time info');
        assert.isTrue(spy.args[0][2], 'AddHeader argument is set');
      });

      test('Calls _computeHistoryTime() with item\'s updated time', () => {
        const item = DataGenerator.generateHistoryObject();
        const time = item.updated;
        const spy = sinon.spy(element, '_computeHistoryTime');
        element._insertItem(item);
        assert.isTrue(spy.called, 'Method is called');
        assert.equal(spy.args[0][0], time, 'Passes "updated" as an argument');
      });

      test('Calls _computeHistoryTime() with item\'s created time', () => {
        const item = DataGenerator.generateHistoryObject();
        delete item.updated;
        const time = item.created;
        const spy = sinon.spy(element, '_computeHistoryTime');
        element._insertItem(item);
        assert.isTrue(spy.called, 'Method is called');
        assert.equal(spy.args[0][0], time, 'Passes "updated" as an argument');
      });

      test('Calls _historyInsertPosition() with item\'s updated time', () => {
        const item = DataGenerator.generateHistoryObject();
        const time = item.updated;
        const spy = sinon.spy(element, '_historyInsertPosition');
        element._insertItem(item);
        assert.isTrue(spy.called, 'Method is called');
        assert.equal(spy.args[0][0], time, 'Passes "updated" as an argument');
      });

      test('Calls _historyInsertPosition() with item\'s created time', () => {
        const item = DataGenerator.generateHistoryObject();
        delete item.updated;
        const time = item.created;
        const spy = sinon.spy(element, '_historyInsertPosition');
        element._insertItem(item);
        assert.isTrue(spy.called, 'Method is called');
        assert.equal(spy.args[0][0], time, 'Passes "updated" as an argument');
      });

      test('Removes header from next item when the same day', () => {
        const item = DataGenerator.generateHistoryObject();
        item.created = item.updated = Date.now();
        const timeInfo = element._computeHistoryTime(item.updated);
        const next = element.requests[0];
        next.created = next.updated = item.created - 1;
        next.hasHeader = true;
        next.dayTime = timeInfo.time;
        next.today = true;
        next.header = 'test';
        const id = next._id;
        element._insertItem(item);
        // next is now at index 1
        const updated = element.requests[1];
        assert.equal(updated._id, id, 'Inserted intem at position 0');
        assert.isFalse(updated.hasHeader, 'Next item\'s hasHeader is false');
        assert.isFalse(updated.today, 'Next item\'s today is false');
        assert.isUndefined(updated.header, 'Next item\'s header is removed');
      });

      test('Next item stays the same if does not have header', () => {
        const item = DataGenerator.generateHistoryObject();
        item.created = item.updated = Date.now();
        const next = element.requests[0];
        next.created = next.updated = item.created - 1;
        const id = next._id;
        element._insertItem(item);
        // next is now at index 1
        const updated = element.requests[1];
        assert.equal(updated._id, id, 'Inserted intem at position 0');
        assert.isUndefined(updated.hasHeader, 'hasHeader is undefined');
      });

      test('Adds header to the item if previous item has no header', () => {
        const item = DataGenerator.generateHistoryObject();
        item.created = item.updated = Date.now();
        element.requests[0].updated = item.created + 1;
        element.requests[1].updated = item.created - 1;
        element._insertItem(item);
        assert.isTrue(item.hasHeader, 'hasHeader is set');
        assert.equal(item.header, 'Today', 'header is set');
        assert.isTrue(item.today, 'today is set');
      });

      test('Header is not added if previous item has the same date', () => {
        const item = DataGenerator.generateHistoryObject();
        item.created = item.updated = Date.now();
        const timeInfo = element._computeHistoryTime(item.updated);
        element.requests[0].updated = item.created + 1;
        element.requests[0].dayTime = timeInfo.time;
        element.requests[1].updated = item.created - 1;
        element._insertItem(item);
        assert.isUndefined(item.hasHeader, 'hasHeader is not set');
      });
    });
  });
  </script>
</body>
</html>
